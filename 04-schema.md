Оригинал: https://getcomposer.org/doc/04-schema.md

>СОДЕРЖАНИЕ ПРОПУЩЕНО

# The composer.json Schema

В этом разделе описываются все свойства (поля) файла composer.json.
 
## Схема JSON 

We have a JSON schema that documents the format and can also be used to validate your composer.json. 
In fact, it is used by the validate command. 
You can find it at: res/composer-schema.json.

##Корневой пакет

Корневой пакет это пакет определяемый файлом composer.json в корневой директории проекта. Это главный файл composer.json который определяет все зависимости проекта. 
 
Некоторые свойства применимы только в контексте корневого пакета. Пример такого свойства - поле `config`. Только корневой пакет может определять конфигурацию. Конфигурации зависимостей игнорируются.

>Замечание: Один и тот же пакет в различных контекстах может быть, а может и не быть корневым. Например, если проект зависит от библиотеки `monolog` - в этом контексте корневым является пакет проекта. Однако, например, при клонировании пакета `monolog` c GitHub для исправления бага, корневым будет считаться пакет `monolog` (скопированный). 

>ПРОПУСК

### autoload

Описывает настройки авторазрузки классов пакета для автозагрузчика PHP.

В данный момент поддерживается автозагрузка по стандартам PSR-0 и PSR-4, автозагрузка по спискам классов и файлов.
Рекомендуется использовать автозагрузку по стандарту PSR-4, так как это наиболее простой способ (нет необходимости генерировать автозагрузчик при добавлении классов).

#### PSR-4

В свойстве `psr-4` задается ассоциативный массив, ключами которого выступают пространства имен, а значениями директории относительно корневой директории пакета. При автозагрузке класса с именем `Foo\\Bar\\Baz` префикс пространства имен `Foo\\` связанный с директорией `src/` означает что автозагрузчик выполнит поиск файла `src/Bar/Baz.php` и если файл будет обнаружен, то выполнит его включение (include it). Следует отметить что в отличие от старого стандарта PSR-0 префикс пространства имен (`Foo\\`) не присутствует в виде директории в пути к файлу. 

Префикс пространства имен должен заканчиваться символами `\\` для предотвращения неодназначности при обработке похожих префиксов. Например, поиск по префиксу `Foo` будет находить классы в пространстве имен `FooBar`, в этом случае завершающие обратные слешы решат проблему: пространства имен `Foo\\` и `FooBar\\` невозможно перепутать.

При установке и обновлении все правила PSR-4 преобразуются в один ассоуиативный массив и помещаются в файл `vendor/composer/autoload_psr4.php`.

Пример:
```json
{
    "autoload": {
        "psr-4": {
            "Monolog\\": "src/",
            "Vendor\\Namespace\\": ""
        }
    }
}
```
Для поиска классов одного пространства имен в нескольких директориях списко директорий можно задать массивом:
```json
{
    "autoload": {
        "psr-4": { "Monolog\\": ["src/", "lib/"] }
    }
}
```
Поиск всех пространств имен в определенной директории задается с помощью пустого префикса:
```json
{
    "autoload": {
        "psr-4": { "": "src/" }
    }
}
```

#### PSR-0

В свойстве psr-0 задается ассоциативный массив, ключами которого выступают пространства имен, а значениями директории относительно корневой директории пакета. Стоит отметить что так же поддерживается описание без пространства имен в стиле PEAR.

Please note namespace declarations should end in \\ to make sure the autoloader responds exactly. 
For example Foo would match in FooBar so the trailing backslashes solve the problem: Foo\\ and FooBar\\ are distinct.

Префикс пространства имен должен заканчиваться символами `\\` для предотвращения неодназначности при обработке похожих префиксов. Например, поиск по префиксу `Foo` будет находить классы в пространстве имен `FooBar`, в этом случае завершающие обратные слешы решат проблему: пространства имен `Foo\\` и `FooBar\\` невозможно перепутать.

При установке и обновлении все правила PSR-0 преобразуются в один ассоуиативный массив и помещаются в файл `vendor/composer/autoload_namespaces.php`.

Пример:
```json
{
    "autoload": {
        "psr-0": {
            "Monolog\\": "src/",
            "Vendor\\Namespace\\": "src/",
            "Vendor_Namespace_": "src/"
        }
    }
}
```
Для поиска классов одного пространства имен в нескольких директориях списко директорий можно задать массивом:
```json
{
    "autoload": {
        "psr-0": { "Monolog\\": ["src/", "lib/"] }
    }
}
```
PSR-0 не ограничивает определение только пространствами имен, можно так же описать пути автозагрузки вплоть до уровня класса. Это может быть полезно для библиотек содержащих единственный класс в глобальном пространстве имен. Например, если php файл содержащий такой класс располагается в корневой директории пакета, то можно описать путь автозагрузки следующим образом:
```json
{
    "autoload": {
        "psr-0": { "UniqueGlobalClass": "" }
    }
}
```
Поиск всех пространств имен в определенной директории задается с помощью пустого префикса:
```json
{
    "autoload": {
        "psr-0": { "": "src/" }
    }
}
```

#### Classmap

Все описания, хранящиеся в `classmap` в процессе установки или обновления объединяются в один ассоциативный массив и помещаются в файл `vendor/composer/autoload_classmap.php`. 
Этот массив получается в результате поиска классов во всех .php и .inc файлах расположенных в описанных директориях или явно указанных в настройке.

Можно использовать загрузку по списку классов для любых библиотек не поддерживающих автозагрузку по стандартам PSR-0/4. Для этого нужну перечислить все необходимые директории и файлы для поиска классов.

Пример:
```json
{
    "autoload": {
        "classmap": ["src/", "lib/", "Something.php"]
    }
}
```

#### Files

Для подключения конкретных файлов при каждом запросе следует использовать механизм автозагрузки по списку файлов. Это может быть полезно для пакетов определяющих функции которые не могут быть автоматически загружены PHP.

Пример:
```json
{
    "autoload": {
        "files": ["src/MyLibrary/functions.php"]
    }
}
```

#### Исключение файлов из списка классов
 
Для исключения файлов и директорий из списмка классов предназначено свойство `exclude-from-classmap`. Например, это может быть полезно для исключения классов тестов на продакшен окружении. Указанные с данном свойстве директории и файлы не будут использоваться для поиска классов даже при построении оптимизированного автозагрузчика.

Пути указываются относительно корневой директории пакета (от расположения файла composer.json). Поддерживаются шаблоны `*` - 'что угодно, до разделителя', '**' - 'что угодно'. Шаблон `**` неявно добавляется в конец любого пути.

Пример:
```json
{
    "autoload": {
        "exclude-from-classmap": ["/Tests/", "/test/", "/tests/"]
    }
}
```
#### autoload-dev ([только для корневого пакета](#Корневой-пакет))

Данное свойство определяет настройки автозагрузки для задач разработки (на время разработки).

Классы предназначенные для тестирования не должны описываться в основных правилах автозагрузки для очистки автолоадера в продакшене и когда пакет используется в качестве зависимости.

Таким образом, хорошим решением будет выделение под тесты отдельной директории и добавление добавлении её в `autoload-dev`.

Пример:
```json
{
    "autoload": {
        "psr-4": { "MyLibrary\\": "src/" }
    },
    "autoload-dev": {
        "psr-4": { "MyLibrary\\Tests\\": "tests/" }
    }
}
```
>ПРОПУСК