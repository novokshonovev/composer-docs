
Оригинал: https://getcomposer.org/doc/02-libraries.md

1. [Каждый проект это пакет](#Каждый-проект-это-пакет)
2. [Пакеты платформы](#Пакеты-платформы)
3. [Задание версии пакета](#Задание-версии-пакета)
    * [Тэги](#Тэги)
    * [Ветки](#Ветки)
    * [Псевдонимы](#Псевдонимы)
4. [Lock файл](#Lock-файл)
5. [Публикация в системе контроля версий](#Публикация-в-системе-контроля-версий)
6. [Публикация на Packagist](#Публикация-на-packagist)    

#Библиотеки

Эта глава раскажет вам как сделать библиотеку устанавливаемой через Composer.

## Каждый проект это пакет

С того момента как в директории появляется файл composer.json эту директорию можно считать пакетом. Когда вы добавляетете зависимости в проек вы по сути создает пакет, который зависит от других пакетов. Единственное отличие проекта от библеотек заключается в том что проект это, обычно, пакет без имени.

Для того что бы сделать этот пакет устанавливаемым необходимо дать ему имя. Имя задается через свойство name в composer.json:
```json
{
    "name": "acme/hello-world",
    "require": {
        "monolog/monolog": "1.0.*"
    }
}
```
В данном примере имя проекта `acme/hello-world`, где `acme` это имя вендора. Указание имени вендора в имени пакета является обязательным.

>Замечание: Если вы не знаете что выбрать в качестве имени вендора, обычно хорошим решением будет использование вашего имени пользователя на GitHub. Стоит, однако, помнить что имена пакетов являются регистронезависимыми, и их принято писать в нижнем регистре, использую тире для разделения слов.


##Пакеты платформы

В Composer определены пакеты платформы. Эти виртуальные пакеты указывают на зависимости пакета от установленного в системе ПО, которое невозможно установить через сам Composer. 
К пакетам платформы относятся: интерперетатор PHP, расширения PHP и некоторые системные библиотеки.

* виртуалный пакет php устанавливает ограничение на версию интерпретатора PHP,например >=5.4.0. Для указания требуемой разрядности установленного пакета также существует виртуальный пакет php-64bit.

* виртуальный пакет hhvm устанавливает ограничение на версию HHVM (HipHop Virtual Machine), например, '>=2.3.3'.

* виртуальные пакеты с именами вида ext-\<name> говорят о зависимости пакета от определенного расширения PHP (в том числе и расширений ядра). Требование определенной версии расширения достаточно неоднозначное решение, поэтому рекомендуется для этих пакетов устанавливать ограничение версии в "*".  Пример имени виртуального пакета расширения PHP - "ext-gd".

* виртуальные пакеты с именами вида lib-\<name> позволяют ограничивать версия используемой PHP библиотеки.Существуют виртуальные пакеты для следующих библиотек: curl, iconv, icu, libxml, openssl, pcre, uuid, xsl.

Для просомтра списка локаьно доступных пакетов платформы можно использовать команду `show --platform`.

## Задание версии пакета

Если вы публикуете ваш пакет на [Packagist](https://packagist.org/), можно явно не указывать версию пакета в composer.json, а получать версию из информации VCS (git, svn, hg). 
Подробнее о формирование версии из информации VCS см. пункты [Теги](#Теги) и [Ветки](#Ветки).  

При создании пакета вручную (не из репозитория VCS) необходимо указать версию пакета в свойстве `version`:
```json
{
    "version": "1.0.0"
}
```

>Замечание: Следует избегать явного указания версии, потому что в случае использования тегов, значение версии в composer.json и в имени тега должно совпадать и это придется поддерживать вручную.

###Тэги

Для любого тега похожего на версию будет создана версия. Версия в теге может быть задана в виде `X.Y.Z` или `vX.Y.Z`. 
Кроме того в версии может присутвовать один из суфиксов `-patch`(`-p`), `-alpha` (`-a`), `-beta` (`-b`) или `-RC`. После суфикса такзе может быть указан номер.

Вот несколько примеров корректных имен тегов:
```
1.0.0
v1.0.0
1.10.5-RC1
v4.4.4-beta2
v2.0.0-alpha
v2.0.4-p1
```

>Замечание: Даже если в теге указана версия с префиксом `v`, в выражениях зависимости (`require`) следует указывать версию без `v`. Например, тэг 'v1.0.0', а в require нужно указывать `1.0.0`.  

###Ветки

Для любой ветки будет создана версия разработки. Если имя ветки выглядит как версия, то будет создана версия `{имя ветки}-dev`.  
Например для ветки `2.0` будет создана версия `2.0.x-dev` (`.x` добавляется по техническим причинам, для того что бы гарантировать распознавание ветки).
Имя ветки `2.0.x` так же является корректным и преобразуется в ту же версию `2.0.x-dev`.   
Если имя ветки не похоже на версию, то будет создана версия `dev-{имя ветки}`. Например для ветки `master` будет создана версия `dev-master`.

Вот несколько примеров корретных имен веток:
```
1.x
1.0 (equals 1.0.x)
1.1.x
```

> Замечание: Если вы устанавливаете версию для разработки она будет автоматически получена из исходников (pulled from its source). Подробнее об этом сказано в описании команды *install*.   

###Псевдонимы

Существует возможность задавать псевдомины для версий сгенерированных из имено веток. Например, можно задать псевдоним `1.0.x-dev` для версии `dev-master` и использовать в выражениях зависимости (`require`) `1.0.x-dev` в любых других пакетах. См. раздел [Aliases(original)](https://getcomposer.org/doc/articles/aliases.md).

##Lock файл

Вы можете добавить в репозиторий своей библиотеки файл composer.lock. Это может помочь вашей команде тестировать все изменения библиотеки c одинаковыми версиями зависимостей. Однако, lock файл не влияет на зависимости проектов, зависящих от самой библиотеки.

Если вы не хотитет использовать composer.lock добавте его в .gitignore.


##Публикация в системе контроля версий

Если у вас есть VCS репозиторий ваашей библиотеки, в котором содержится файл composer.json, то ваша библиотека уже может быть установлена через Composer.
Далее на примере разбирается публикация пакета `acme/hello-world` на GitHub в репозиторий `github.com/username/hello-world`.   

Для проверки пубикации и установки библиотеки `acme/hello-world` создадим локальный проект c имененм `acme/blog`. 
Проект `blog` будет зависеть от `acme/hello-world`, который в свобю очередь зависит от `monolog/monolog`.   
Создадим директорию `blog` c файлом composer.json следующего содержания:
```
{
    "name": "acme/blog",
    "require": {
        "acme/hello-world": "dev-master"
    }
}
```

По идее, в данном примере имя проекта `"name": "acme/blog",` не нужно, так как мы не собираемся публиковать проект как библиотеку. Оно добавлено для того что бы однозначно указать о каком файле composer.json идет речь.

Далее, укажем откуда следует получать зависимость `hello-world`. Для этого добавим спецификацию репозитория пакета в composer.json проекта `blog`:
```
{
    "name": "acme/blog",
    "repositories": [
        {
            "type": "vcs",
            "url": "https://github.com/username/hello-world"
        }
    ],
    "require": {
        "acme/hello-world": "dev-master"
    }
}
```

Подробнее о принципах работы репозиторием пакетах и достпных типах репозиториев см. раздел [Repositories(original)](https://getcomposer.org/doc/05-repositories.md)

Собственно все. Теперь можно установить зависимость командой  `composer install`!

>Замечание: Зависимость может быть получена из любого репозитория git/svn/hg, содержащего файл composer.json. 

## Публикация на Packagist

Хорошо, теперь вы можете публиковать пакеты. Но описание репозитория VCS репозитория каждый раз для каждого пакеты 
представляется достаточно громоздким. Вы не хотитет заставлять каждого использующего ваш пакет делать это. 

Кроме того, как вы возможно заметили в примере не описан репозиторий для пакета `monolog/monolog`. Как это работате? Ответ - Packagist.

Packagist это главный репозиторий пакетов для Composer и он доступен по умолчанию. Все что опубликовано на Packagist автоматически доступно для установки через Composer. Так как пакет [`monolog/monolog` опубликован на Packagist](https://packagist.org/packages/monolog/monolog), мы может указывать его в качестве зависимости без описания его репозитория. 

Если бы мы захотели поделиться пакетом `hello-world` с миром, мы бы так же опубликовали его на Packagist. Сделать это действительно просто.

Вы заходите на [Packagist](https://packagist.org/) и нажимаете "Submit". Регистрируетесь если еще не зарегистрированы, после чего Packagist даст возможность отправить ссылку на ваш VCS репозиторий. После сканирования репозитория ваш пакет будет доступен кому угодно! 