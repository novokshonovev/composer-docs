Оригинал: https://getcomposer.org/doc/01-basic-usage.md

1. [Вступление](#Вступление)
2. [Файл настройки проекта: composer.json](#Файл-настройки-проекта-composerjson)
    * [Зависимости: свойство require](#Зависимости-свойство-require)
    * [Имена пакетов](#Имена-пакетов)
    * [Версии пакетов](#Версии-пакетов)
    * [Стабильность](#Стабильность)
3. [Файл блокировки: composer.lock](#Файл-блокировки-composerlock)
4. [Packagist](#Packagist)
5. [Автозагрузка](#Автозагрузка)

# Основы использования

## Вступление

В качестве инструкции по основным возможностям Composer будет описан процесс установки библиотеки логгирования - пакета `monolog/monolog`. 
Описания установки Composer описано в разделе [Intro(original)](https://getcomposer.org/doc/00-intro.md)
>Замечание: для простоты описания исходим из того что выполнена [локальная установка Composer (original)](https://getcomposer.org/doc/00-intro.md#locally).

## Файл настройки проекта: composer.json

Для того что бы начать использовать Composer в проекте достаточно наличие в нем файла composer.json. Данный файл, в основном, описывает зависимости проекта, но може так же содержать и другую метаинформацию.

## Зависимости: свойство require 

Первое и часто единственно что должен содержать файл composer.json это свойство [`require`(original)](https://getcomposer.org/doc/04-schema.md#require). В нем задается описание зависимостей проекта от внешних пакетов.
```json
{
    "require": {
        "monolog/monolog": "1.0.*"
    }
}
```
Как видно из примера в `require` хранится объект, именами свойств (ключами) которого выступают имена пакетов (в примере, `monolog/monolog`), а их значениями ограничения версий (в примере `1.0.*`). 

### Имена пакетов

Имя пакета состоит из имени вендора и собственного имени пакета. Часто имена вендора и пакета совпадают - имя вендора использутеся только для предотвращения конфликта имен пакетов. Возможна ситуация когда два разных разработчика создадут бибилиотеки с одинаковым именем `json`, в этом случае уникальность имен их пакетов будет определяться именами вендоров: `igorw/json` и `seldaek/json`. 

В примере имя пакета совпадает с именем вендора: `monolog/monolog`. Для проектов с уникальными именами рекомендуется именно такой подход. Это так же позволит в будущем расширить пространство имен вендора еще несколькими проектами. Для разработки библиотек такой подход так же оставляет возможность легко разбить библиотеку на составные части. 

### Версии пакетов

В примере указана зависимость от пакета `monolog/monolog` версии `1.0.*`. This means any version in the 1.0 development branch. Данное выражение означает "любая версия ветки 1.0". Другими словами подходит любая версия удовлетворяющая условиям `>=1.0` и `<1.1`.   

Ограничение версии может быть задане несколькими способами, подробнее об этом сказано в разделе [Versions(original)](https://getcomposer.org/doc/articles/versions.md). 

### Стабильность

По умолчанию рассматриваются только стабильные релизы пакетов.
Для получения `RC`, `beta`, `alpha` или `dev` версий пакетов следует установить [флаги стабильности(original)](https://getcomposer.org/doc/04-schema.md#package-links). 
Для того что бы указать ограничение стабильности для всех пакетов сразу можно использовать свойство [minimum-stability(original)](https://getcomposer.org/doc/04-schema.md#minimum-stability).  

## Установка зависимостей

Для установки объявленных в проекте зависимостей достаточно выполнить команду [`install`(original)](https://getcomposer.org/doc/03-cli.md#install): 
```
php composer.phar install
```
В результате будет найдена последняя версия пакета `monolog/monolog` которая удовлетворяет указанным ограничениям, которая будет загружена в директорию `vendor\<имя вендора>`. По соглашению все ПО, разработанное другими вендорами помещается в директироию `vendor`. В случае с пакетом `monolog/monolog` он будет помещен в директорию `vendor/monolog/monolog`.

>Совет: В случае использования git имеет смысл добавить директорию `vendor` в .gitignore что бы не хранить все внешние пакеты в своем репозитории.

В результате команды [`install`(original)](https://getcomposer.org/doc/03-cli.md#install) в проекте так же появится файл composer.lock 

## Файл блокировки: composer.lock

После установки зависимостей Composer записывает версии установленных пакетов в файл composer.lock. Это фиксирует состояние проекта на конкретных версиях зависимостей. 

**Храните composer.lock проекта вместе с composer.json в системе контроля версий**

Это важно потому что при выполнении команды [`install`(original)](https://getcomposer.org/doc/03-cli.md#install) сначала проверяется наличие lock файла, и если он существует, то производится установка именно тех версий зависимостей, которые в нем указаны, независимо от того что указано в composer.json. 

Это означает что при любом разворячивании проекта всегда будут загружены одни и те же версии зависимостей.
Сервер непрерывной интеграции, продакшен серверы, машины других разработчиков команды, все и все будут работать с одними теми же зависимостями. Это снижает вероятность ошибок. 

Даже в случае одиночной разработки, при рестарте проекта через шесть месяцев, все зависимые пакеты работают ровно так же, даже если с тех пор было выпущено несколько релизов зависимостей. 

Если файла composer.lock не существует Composer получит зависимости и их версии из файла composer.json и создаст файл блокировки после выполнения команд [`update`(original)](https://getcomposer.org/doc/03-cli.md#update)  или [`install`(original)](https://getcomposer.org/doc/03-cli.md#install).


Это означает релиз новой версии зависимости не влечет автоматическое обновление пакета в проекте. Для обновления следует использовать команду [`update`(original)](https://getcomposer.org/doc/03-cli.md#update). Это приведет к определению последней версии пакета в соответвии с параметрами composer.json. 
Если стала доступна новая версия зависимости она будет установлена. Так же будет обновен файл блокировки.  
```
php composer.phar update
```
> Замечание: Composer отобразит предупреждение если при запуске команды [`install`(original)](https://getcomposer.org/doc/03-cli.md#install) файлы composer.lock и composer.json рассинхронизированы.

Если необходимо установить или обновить конкретную зависимость, то её можно явно указать в команде:
```
php composer.phar update monolog/monolog [...]
```
> Замечание: Для библиотек не обязательно хранить файл блокировки в VCS.

## Packagist

Packagist это главный репозиторий Composer. Репозиторий Composer это, обычно, ресурс пакета: место из которого пакет может быть получен. Packagist это репозиторий известный Composer по умолчанию. Это означает что зависимость от любого пакета доступного на Packagist будет автоматически разрешена.

На сайте [Packagist](https://packagist.org/) доступны описания пакетов и поиск по ним.

Для любого [Packagist](https://packagist.org/) open source проекта, использующего Composer рекомендуется публиковать пакеты на Packagist. 

Пакет не обязательно должен быть опубликован на Packagist что бы он он был доступен для установки через Composer, но это позволяет ускорить процессы поиска и принятия пакета. 

## Автозагрузка

Для библиотек в которых описана информация для автозагрузки Composer  генерирует файл `vendor/autoload.php file`. 
Для автозагрузки достаточно просто выполнить включение данного файла.
```php
require __DIR__ . '/vendor/autoload.php';
```
Это позволяет действительно легко подключать чужой код к проекту. 

You can even add your own code to the autoloader by adding an autoload field to composer.json.
Можно даже добавить собственный код автозагрузчика через свойство [`autoload`(original)](https://getcomposer.org/doc/04-schema.md#autoload) файла composer.json: 
```json
{
    "autoload": {
        "psr-4": {"Acme\\": "src/"}
    }
}
```

Composer зарегистрирует [PSR-4](http://www.php-fig.org/psr/psr-4/) автозагрузчик для пространства имен `Acme`.

В примере определяется соответсвие между пространством имен и директорией.   
Директория `src` должна располагаться в корне вашего проекта на том же уровне что и директория `vendor`.

После добавления свойства [`autoload`(original)](https://getcomposer.org/doc/04-schema.md#autoload) необходимо выполнить команду [`dump-autoload`(original)](https://getcomposer.org/doc/03-cli.md#dump-autoload) для обновления файла autoload.php.

Кроме того включение файла автозагрузки вернет объект автозагрузчика через который можно добавить в автозагрузку другие пространства имен.
Это может быть полезно, например. при организации тестирования:
```php
$loader = require __DIR__ . '/vendor/autoload.php';
$loader->add('Acme\\Test\\', __DIR__);
```

Кроме автозагрузки по стандарту PSR-4 Composer так же поддерживает автозагрузку по стандарту PSR-0, автозагрузку по спискам классов (classmap) and файлов. Подробнее автозагрузка рассмотрена в [`autoload`(original)](https://getcomposer.org/doc/04-schema.md#autoload).

>Замечание: Composer имеет встроенный автозагрузчик. Для использования другого автозагрузчика можно выполнить включение файлов `vendor/composer/autoload_*.php`, которые вернут ассоциативные массивы для настройки автозагрузки.
